Execute (setup):
  perl require VIMx;

Before:
  unlet! b:eep b:eep2 b:oop

Execute(basic tie tests):
  perl $VIMx::b{eep} = 'one'
  AssertEqual 'one', b:eep
  perl delete $VIMx::b{eep}
  Assert !has('b:eep')

Execute(complex-ish tie tests):
  perl $VIMx::b{eep} = [1, 2, 3]
  AssertEqual [1, 2, 3], b:eep
  perl $VIMx::b{eep} = { one => [1, 2, 3] }
  AssertEqual { 'one': [1, 2, 3] }, b:eep

Execute (reference execution tie tests):
  perl $VIMx::b{eep} = \'1 + 1'
  AssertEqual 2, b:eep

Execute (defined-or setting on non-extant slot):
  perl $VIMx::b{eep} //= 42
  AssertEqual 42, b:eep

Execute (delete returns value):
  unlet! b:eep b:eep2
  let b:eep2 = 84
  perl $VIMx::b{eep} = delete $VIMx::b{eep2}
  AssertEqual 84, b:eep

Execute (concatenation works):
  perl $VIMx::b{eep}  = 'This'
  perl $VIMx::b{eep} .= ' worked!'
  AssertEqual 'This worked!', b:eep

Execute (concatenation works, redux):
  perl $VIMx::b{eep}   = 'This'
  perl $VIMx::b{eep} //= 'ARRGH'
  perl $VIMx::b{eep}  .= ' worked!'
  AssertEqual 'This worked!', b:eep

Execute (keys):
  let b:eep = { 'a': 1, 'b': 2, 'c': 3 }
  perl $VIMx::b{oop} = [ sort keys %{ $VIMx::b{eep} } ]
  AssertEqual [ 'a', 'b', 'c' ], b:oop
  unlet! b:eep b:oop
